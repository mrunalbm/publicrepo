pipeline {
    options {
        disableConcurrentBuilds()
        ansiColor('xterm')
    }

    agent any

    parameters {
	choice(choices: ['dev', 'test'], description: 'Type the name of the environment you want to update', name: 'EnvironmentName')    
    }

    environment {
        // Time to wait for a manual approval before running `terraform apply` (in minutes).
        approval_timeout = 30
        // Relative path to the Terraform environment directory. This directory should contain the
        // "root" module for every environment which this pipeline manages.
        environment_dir = "${WORKSPACE}/terraformscripts"
        // Path to the Terraform executable.
        tf_command = '/usr/bin/terraform'
        // Send email notifications.
        email = false
        }

    stages {
        stage ('Initializing ...') {
            steps {
                script {
                    environment = params.EnvironmentName
                    if (!environment?.trim()) {
                        error "Environment name cannot be empty."
                    }
                    echo "${environment_dir}/${environment}"
                    if (!fileExists("${environment_dir}/${environment}")) {
                        error "Cannot find environment '${environment}'."
                    }

                    echo "Running Terraform for environment ${environment}"

                    // Set build name so that we can easily figure out which for which environment it ran.
                    currentBuild.displayName = "#${BUILD_NUMBER}-${environment}"
                    
                    dir("${environment_dir}/${environment}") {
                        sh "${tf_command} init -input=false"
                        // Variable used to see if terraform was run before or not
                        created = sh(script: "${tf_command} show -no-color", returnStdout: true).trim()
                    }
                }
            }
        }
        stage ('Plan') {
            steps {
                script {
                    dir("${environment_dir}/${environment}") {
                        exitCode = sh script: "${tf_command} plan -detailed-exitcode -input=false -out=tfplan", returnStatus: true

                        // Stash plan output so that it can be reused by other nodes. In some cases,
                        // Jenkins might schedule a part of a build to a different node. In these
                        // cases, stashing allows the new node to use files which were generated by the
                        // previous node.
                        stash includes: 'tfplan', name: 'tfplans'
                        
                    }
                }
            }
        }
        stage ('Apply') {
            when {
                expression { exitCode == 2 }
            }
            steps {
                script {
                    timeout(time: env.approval_timeout, unit: 'MINUTES') {
                        input 'Apply?'
                    }
                    
                    dir("${environment_dir}/${environment}") {
                        // Unstash plan output.
                        unstash name: 'tfplans'
                        sh "${tf_command} apply -input=false tfplan"
                        // TODO Notify on failure (with output).
                    }
                }
            }
        }
    }
    post {
        always {
            script {
                if (exitCode == 1) {
                    currentBuild.result = 'FAILURE'
                } else if (exitCode == 0) {
                        currentBuild.result = 'SUCCESS'
                        echo 'Nothing to change'
                } else {
                    currentBuild.result = 'SUCCESS'
                    echo 'Changes applied successfully!'
                }
            }
        }
    }
}